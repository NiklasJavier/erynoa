{
  "meta": {
    "version": "2.0.0",
    "phase": "1.5: Migration Script Formalization",
    "source_documents": ["05-MIGRATION-SCRIPTS.md"],
    "description": "Mathematische Formalisierung der Projekt-Pluto Migrationslogik"
  },
  "migration_algebra": {
    "domain": {
      "FileSystem": "FS = (Paths: ùí´(String), Contents: Map<Path, Bytes>)",
      "GitState": "G = (Commits: List<Hash>, Branches: Map<Name, Hash>, WorkTree: FS)",
      "CompilationState": "C ‚àà {Success, Failure(Errors)}",
      "TestState": "T = (Passed: ‚Ñï, Failed: ‚Ñï, Skipped: ‚Ñï)"
    },
    "state_tuple": "M = (FS, G, C, T)"
  },
  "operations": {
    "Œ¶_setup": {
      "symbol": "Œ¶_setup",
      "signature": "FS ‚Üí FS'",
      "precondition": "‚àÉ src: Path ‚àß IsDir(src)",
      "postcondition": "‚àÄd ‚àà TargetDirs: IsDir(d) ‚àß ‚àÉ mod.rs ‚àà d",
      "target_dirs": [
        "nervous_system/{event_sourcing, merkle, components, graph, infrastructure}",
        "synapses/adapters",
        "realm/{sharding, quota, gateway, saga}",
        "storage/{kv, event_store, identity_store, trust_store, content_store, archive, realm, blueprint, metrics}",
        "identity",
        "engines"
      ],
      "idempotent": true,
      "description": "Erstellt die Zielverzeichnisstruktur. Idempotent (mehrfach ausf√ºhrbar)."
    },
    "Œ¶_extract": {
      "symbol": "Œ¶_extract",
      "signature": "(FS, Source, Target, LineRange) ‚Üí FS'",
      "precondition": "‚àÉ Source ‚àß |Lines(Source)| ‚â• max(LineRange)",
      "postcondition": "Content(Target) = Header ‚äï Slice(Source, LineRange)",
      "formula": "FS'[Target] = inject_header(extract_lines(FS[Source], start, end))",
      "instances": {
        "EventBus": {
          "source": "core/state.rs",
          "target": "nervous_system/infrastructure/event_bus.rs",
          "range": "[39, 400]"
        }
      },
      "description": "Extrahiert Code-Segmente mit Header-Injektion."
    },
    "Œ¶_backup": {
      "symbol": "Œ¶_backup",
      "signature": "(FS, G) ‚Üí (FS', BackupRef)",
      "formula": "BackupRef = 'pluto_' ‚äï timestamp(now())",
      "postcondition": "‚àÉ BackupDir ‚àß Content(BackupDir) ‚âÖ Content(src)",
      "reversible": true,
      "description": "Erstellt timestamped Backup vor destruktiven Operationen."
    },
    "Œ¶_check": {
      "symbol": "Œ¶_check",
      "signature": "FS ‚Üí (C, T)",
      "formula": "C = cargo_check(FS) ‚àß T = cargo_test(FS)",
      "oracle": "Compiler + TestSuite",
      "description": "Validiert Kompilierbarkeit und Testintegrit√§t."
    },
    "Œ¶_imports": {
      "symbol": "Œ¶_imports",
      "signature": "FS ‚Üí FS'",
      "transformations": [
        { "pattern": "crate::core::state::", "replacement": "crate::nervous_system::" },
        { "pattern": "crate::peer::p2p::", "replacement": "crate::p2p::" },
        { "pattern": "crate::local::", "replacement": "crate::storage::" }
      ],
      "formula": "‚àÄf ‚àà RustFiles(FS): FS'[f] = sed_replace(FS[f], transformations)",
      "description": "Globale Import-Pfad-Transformation via sed."
    },
    "Œ¶_deprecate": {
      "symbol": "Œ¶_deprecate",
      "signature": "(OldPath, NewPath) ‚Üí ReExportDecl",
      "formula": "#[deprecated(since='0.5.0', note='Use {NewPath}')] pub use ...",
      "purpose": "Backwards-Compatibility w√§hrend Migration",
      "description": "Generiert deprecated Re-Exports f√ºr sanfte Migration."
    },
    "Œ¶_rollback": {
      "symbol": "Œ¶_rollback",
      "signature": "(FS, BackupRef) ‚Üí FS'",
      "precondition": "‚àÉ BackupRef ‚àß IsValid(BackupRef)",
      "postcondition": "FS' ‚âÖ Snapshot(BackupRef)",
      "inverse_of": "Œ¶_extract, Œ¶_imports",
      "description": "Stellt vorherigen Zustand aus Backup wieder her."
    }
  },
  "execution_graph": {
    "nodes": ["Œ¶_backup", "Œ¶_setup", "Œ¶_extract", "Œ¶_check_1", "Œ¶_imports", "Œ¶_check_2", "Œ¶_deprecate"],
    "edges": [
      { "from": "START", "to": "Œ¶_backup", "label": "init" },
      { "from": "Œ¶_backup", "to": "Œ¶_setup", "label": "seq" },
      { "from": "Œ¶_setup", "to": "Œ¶_extract", "label": "seq" },
      { "from": "Œ¶_extract", "to": "Œ¶_check_1", "label": "validate" },
      { "from": "Œ¶_check_1", "to": "Œ¶_imports", "condition": "C = Success" },
      { "from": "Œ¶_check_1", "to": "Œ¶_rollback", "condition": "C = Failure", "label": "abort" },
      { "from": "Œ¶_imports", "to": "Œ¶_check_2", "label": "validate" },
      { "from": "Œ¶_check_2", "to": "Œ¶_deprecate", "condition": "C = Success" },
      { "from": "Œ¶_check_2", "to": "Œ¶_rollback", "condition": "C = Failure", "label": "abort" },
      { "from": "Œ¶_deprecate", "to": "END", "label": "complete" }
    ],
    "formula": "Pipeline = Œ¶_backup ; Œ¶_setup ; (Œ¶_extract ; Œ¶_check)* ; Œ¶_imports ; Œ¶_check ; Œ¶_deprecate"
  },
  "constraints": {
    "M1": {
      "id": "M1",
      "name": "BackupBeforeDestruction",
      "formalism": "‚àÄ Œ¶_destructive: ‚àÉ Œ¶_backup < Œ¶_destructive",
      "description": "Jede destruktive Operation muss ein Backup vorausgehen."
    },
    "M2": {
      "id": "M2",
      "name": "CheckAfterMutation",
      "formalism": "‚àÄ Œ¶_mutate ‚àà {Œ¶_extract, Œ¶_imports}: Œ¶_mutate ‚Üí Œ¶_check",
      "description": "Nach jeder Mutation muss validiert werden."
    },
    "M3": {
      "id": "M3",
      "name": "RollbackSafety",
      "formalism": "Œ¶_rollback(Œ¶_rollback(s, ref), ref) = Œ¶_rollback(s, ref)",
      "description": "Rollback ist idempotent."
    },
    "M4": {
      "id": "M4",
      "name": "AtomicPhase",
      "formalism": "Phase_complete ‚ü∫ (C = Success ‚àß T.Failed = 0)",
      "description": "Eine Phase gilt nur bei gr√ºnem Build + Tests als abgeschlossen."
    },
    "M5": {
      "id": "M5",
      "name": "GitTrace",
      "formalism": "‚àÄ Phase_i: ‚àÉ commit_i ‚àà G.Commits",
      "description": "Jede Phase muss als Git-Commit dokumentiert sein."
    }
  },
  "git_workflow": {
    "branch_formula": "Branch = 'refactor/projekt-pluto'",
    "commit_pattern": "Phase {i}: {description}",
    "merge_condition": "‚àÄ Œ¶_check: C = Success",
    "tag": "v0.5.0",
    "operations": {
      "create_branch": "G' = G[branches += {Branch ‚Üí HEAD}]",
      "commit": "G' = G[commits += {Hash(diff)}, HEAD ‚Üí Hash]",
      "merge": "G' = G[main ‚Üí merge(main, Branch)]",
      "tag": "G' = G[tags += {'v0.5.0' ‚Üí HEAD}]"
    }
  },
  "metrics": {
    "line_count": {
      "formula": "Lines(module) = Œ£ |file| for file ‚àà RustFiles(module)",
      "purpose": "Validierung der Code-Verteilung nach Refactoring",
      "target_modules": [
        "nervous_system", "synapses", "identity", "engines", 
        "realm", "protection", "p2p", "storage", "eclvm"
      ]
    },
    "extraction_ratio": {
      "formula": "Ratio = Lines(extracted) / Lines(original)",
      "validation": "Ratio ‚âà 1.0 (keine Code-Verluste)"
    }
  },
  "synergies": {
    "Migration->Git": {
      "name": "Atomic Commits",
      "formula": "Phase_complete ‚üπ Commit",
      "description": "Jede erfolgreich abgeschlossene Phase wird committet."
    },
    "Backup->Rollback": {
      "name": "Reversibility Chain",
      "formula": "Œ¶_rollback ‚àò Œ¶_backup = id",
      "description": "Backup + Rollback sind inverse Operationen."
    },
    "Check->Pipeline": {
      "name": "Fail-Fast",
      "formula": "C = Failure ‚üπ ¬¨continue(Pipeline)",
      "description": "Fehler stoppen die Pipeline sofort."
    }
  }
}
