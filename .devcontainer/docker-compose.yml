name: erynoa-dev

services:
  # ─────────────────────────────────────────────────────────────────────────
  # DevContainer - Hauptentwicklungsumgebung
  # ─────────────────────────────────────────────────────────────────────────
  dev:
    build:
      context: .
      dockerfile: Dockerfile
    volumes:
      # Workspace-Code (ohne schwere Build-Outputs)
      - ..:/workspace:cached
      # Rust target-Verzeichnis NICHT auf den Host spiegelt – eigenes Volume
      - rust_target:/workspace/backend/target
      # Node.js: node_modules im Container halten, nicht auf den Host spiegeln
      - console_node_modules:/workspace/frontend/console/node_modules
      - platform_node_modules:/workspace/frontend/platform/node_modules
      - docs_node_modules:/workspace/frontend/docs/node_modules
      # Nix & apt Caches
      - nix-store:/nix
      - apt-cache:/var/cache/apt
      - apt-lib:/var/lib/apt
      # ⚡ CACHING: Cargo Registry persistent (muss mit devcontainer.json mounts übereinstimmen)
      - cargo-cache:/usr/local/cargo
      # ⚡ CACHING: pnpm Store persistent
      - pnpm-store:/home/vscode/.local/share/pnpm
      # SSH-Agent vom Host durchleiten (für git push)
      - ${SSH_AUTH_SOCK:-/dev/null}:/ssh-agent:ro
    environment:
      - SSH_AUTH_SOCK=/ssh-agent
      # App-Datenbank Verbindung (auf Host laufend)
      # host.docker.internal zeigt auf den Docker-Host (lokal oder Remote-Server)
      # Auf Remote-Server: Services müssen auf dem Remote-Server laufen
      # 
      # SERVICE_HOST: Optional, um Services auf anderem Host zu nutzen
      # - Wird vom Host-System gelesen (nicht aus Container)
      # - Setze auf dem Host: export SERVICE_HOST=192.168.1.100
      # - Oder in .env Datei im Workspace-Root
      # - Standard: host.docker.internal (Docker-Host)
      - APP_DATABASE__HOST=${SERVICE_HOST:-host.docker.internal}
      - APP_DATABASE__PORT=5432
      - APP_DATABASE__USERNAME=erynoa
      - APP_DATABASE__PASSWORD=erynoa
      - APP_DATABASE__DATABASE=erynoa
      # Cache Verbindung (auf Host laufend)
      - APP_CACHE__URL=redis://${SERVICE_HOST:-host.docker.internal}:6379
      # Storage Verbindung (auf Host laufend)
      - APP_STORAGE__ENDPOINT=http://${SERVICE_HOST:-host.docker.internal}:9000
      - APP_STORAGE__ACCESS_KEY_ID=erynoa
      - APP_STORAGE__SECRET_ACCESS_KEY=erynoa123
      # ZITADEL Auth (auf Host laufend)
      - APP_AUTH__ISSUER=http://${SERVICE_HOST:-host.docker.internal}:8080
      - APP_AUTH__INTERNAL_ISSUER=http://${SERVICE_HOST:-host.docker.internal}:8080
    # Extra hosts für host.docker.internal (Linux-Support)
    # Wird nur benötigt wenn SERVICE_HOST nicht gesetzt ist
    # Harmlos wenn SERVICE_HOST gesetzt ist (wird ignoriert)
    extra_hosts:
      - "host.docker.internal:host-gateway"
    command: sleep infinity

# ─────────────────────────────────────────────────────────────────────────
# Services wurden entfernt - sie müssen auf dem Host laufen
# Services sind in infra/docker/docker-compose.yml definiert
#
# WICHTIG: Services laufen auf dem Docker-Host
# - Lokaler DevContainer → Services auf lokalem Rechner
# - Remote DevContainer → Services auf Remote-Server
#
# Starte Services auf dem Host mit:
#   cd infra/docker && docker compose up -d db cache minio
#   oder: just services
#
# Alternative: Services auf anderem Host
#   Setze SERVICE_HOST auf dem Host-System (nicht im Container):
#   - export SERVICE_HOST=192.168.1.100  (vor DevContainer-Start)
#   - Oder in .env Datei im Workspace-Root
#   - Docker Compose liest diese Variable vom Host-System
# ─────────────────────────────────────────────────────────────────────────

volumes:
  # DevContainer Caches
  nix-store:
  apt-cache:
  apt-lib:
  rust_target:
  console_node_modules:
  platform_node_modules:
  docs_node_modules:
  # ⚡ Persistente Caches (verhindert Re-Downloads bei Rebuild)
  cargo-cache:
  pnpm-store:
