# ============================================================================
# Backend Dockerfile mit cargo watch fÃ¼r Hot-Reloading
# Optimiert fÃ¼r Container-in-Container (DinD) Entwicklungsumgebung
# ============================================================================
# Verwendet Debian (Bookworm) statt Alpine fÃ¼r bessere KompatibilitÃ¤t mit
# aws-lc-sys und anderen nativen Dependencies

FROM rust:1.88-bookworm

# Setze Umgebungsvariablen fÃ¼r bessere Build-Performance
ENV CARGO_INCREMENTAL=1 \
    CARGO_NET_GIT_FETCH_WITH_CLI=true \
    RUST_BACKTRACE=1

# âš¡ System AbhÃ¤ngigkeiten inkl. MOLD Linker (3-10x schneller!)
RUN apt-get update && apt-get install -y --no-install-recommends \
    postgresql-client \
    ca-certificates \
    curl \
    build-essential \
    pkg-config \
    libssl-dev \
    cmake \
    clang \
    mold \
    unzip \
    && rm -rf /var/lib/apt/lists/*

# Installiere buf fÃ¼r Proto-Code-Generierung (fÃ¼r Frontend)
RUN BUF_VERSION=1.36.0 && \
    curl -sSL "https://github.com/bufbuild/buf/releases/download/v${BUF_VERSION}/buf-Linux-x86_64" \
    -o "/usr/local/bin/buf" && \
    chmod +x /usr/local/bin/buf

# âš¡ cargo-binstall fÃ¼r extrem schnelle Tool-Installation (Sekunden statt Minuten!)
RUN curl -L --proto '=https' --tlsv1.2 -sSf https://raw.githubusercontent.com/cargo-bins/cargo-binstall/main/install-from-binstall-release.sh | bash
RUN cargo binstall cargo-watch -y --force
# âš¡ cargo-nextest: Test-Runner der nÃ¤chsten Generation (60% schneller, bessere UI)
RUN cargo binstall cargo-nextest -y --force
# âš¡ GOD MODE: cargo-pgo fÃ¼r Profile-Guided Optimization (+10-15% Throughput)
RUN cargo binstall cargo-pgo -y --force

WORKDIR /workspace/backend

# WICHTIG: Kopiere NICHT alle Dateien - sie werden via Volume gemountet!
# Nur den Cargo.toml, Cargo.lock und build.rs fÃ¼r Dependency-Locking
COPY backend/Cargo.toml ./Cargo.toml
COPY backend/Cargo.lock ./Cargo.lock
COPY backend/build.rs ./build.rs

# Pre-fetch dependencies (fÃ¼r schnellere Rebuilds)
# Das speichert die Dependencies im Docker Layer fÃ¼r schnellere Builds
# âš¡ Nutze MOLD Linker fÃ¼r schnelleres Pre-Building
RUN mkdir -p src && \
    echo "fn main() {}" > src/main.rs && \
    echo "// lib" > src/lib.rs && \
    RUSTFLAGS="-C link-arg=-fuse-ld=mold" cargo build --lib 2>&1 || true && \
    RUSTFLAGS="-C link-arg=-fuse-ld=mold" cargo build --bin erynoa-api 2>&1 || true && \
    rm -rf src

WORKDIR /workspace/backend

# Exponiere API Port
EXPOSE 3000

# Erstelle ein Startup-Script fÃ¼r ECLVM (kein externes DB benÃ¶tigt - nutzt Fjall embedded)
RUN cat > /entrypoint.sh << 'EOF'
#!/bin/bash
set -e

echo "========================================="
echo "ðŸš€ Erynoa Backend Container Starting..."
echo "   Mode: ECLVM (Embedded Fjall Storage)"
echo "========================================="

# Starte cargo watch mit optimierten Einstellungen
echo ""
echo "Starting cargo watch with hot-reload..."
echo "  â”œâ”€ Code changes in src/ will trigger rebuild"
echo "  â”œâ”€ Watching: src/, Cargo.toml, config/"
echo "  â””â”€ âš¡ Using MOLD linker for fast rebuilds"
echo ""
echo "========================================="

# --poll fÃ¼r bessere KompatibilitÃ¤t in Container-Umgebungen
# --why zeigt an welche Datei den Rebuild ausgelÃ¶st hat
# âš¡ MOLD Linker fÃ¼r schnelle Rebuilds
export RUSTFLAGS="-C link-arg=-fuse-ld=mold"
exec cargo watch --poll --why \
  -x "run --bin erynoa-api" \
  -w src \
  -w Cargo.toml \
  -w config \
  -w proto
EOF

RUN chmod +x /entrypoint.sh

# âš¡ Permissions Fix: Non-Root User (verhindert "Permission denied" auf Host)
ARG USERNAME=dev
ARG USER_UID=1000
ARG USER_GID=$USER_UID

RUN groupadd --gid $USER_GID $USERNAME \
    && useradd --uid $USER_UID --gid $USER_GID -m $USERNAME \
    && chown -R $USERNAME:$USERNAME /usr/local/cargo \
    && chown -R $USERNAME:$USERNAME /workspace

USER $USERNAME

ENTRYPOINT ["/entrypoint.sh"]
